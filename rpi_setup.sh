#!/bin/bash

# --- Sudo check ---
if [[ $EUID -ne 0 ]]; then
   echo -e "\n\033[0;31mThis script must be run with sudo privileges.\033[0m" 
   echo -e "Please run it as: \033[1;33msudo ./rpi_setup.sh\033[0m\n"
   exit 1
fi

# ================================================================= #
#                  Raspberry Pi Setup Script                        #
# ================================================================= #
#                                                                   #
#  A simple script to automate the setup of a new Raspberry Pi.     #
#                                                                   #
# ================================================================= #


# --- Colors for better readability ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# --- State Tracking ---
# We'll use functions to check the status of each component.
# A variable to track if the system update has been run in this session.
UPDATE_RUN_THIS_SESSION=false

# --- Development Environment Paths ---
# Get the actual user's home directory (not root's when using sudo)
if [ -n "$SUDO_USER" ]; then
    USER_HOME=$(eval echo "~$SUDO_USER")
else
    USER_HOME="$HOME"
fi

DEVELOPER_DIR="$USER_HOME/Developer"
DOCKER_CONTAINERS_DIR="$DEVELOPER_DIR/docker_containers"
CONFIGS_DIR="$DOCKER_CONTAINERS_DIR/configs"
VOLUMES_DIR="$DOCKER_CONTAINERS_DIR/volumes"
COMPOSE_FILE="$CONFIGS_DIR/docker-compose.yml"
CONFIG_FILE="$CONFIGS_DIR/container_configs.txt"

# --- Directory Setup Functions ---
create_developer_structure() {
    echo -e "\n${GREEN}>>> Creating Developer directory structure...${NC}"
    
    # Get the actual user (not root when using sudo)
    ACTUAL_USER="${SUDO_USER:-$USER}"
    
    # Create main directories
    sudo -u "$ACTUAL_USER" mkdir -p "$CONFIGS_DIR"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR"
    
    # Create individual service volume directories
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/mongodb"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/mysqldb"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/sqlite"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/influxdb"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/grafana"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/portainer"
    sudo -u "$ACTUAL_USER" mkdir -p "$VOLUMES_DIR/traefik"
    
    # Ensure proper ownership of all directories
    sudo chown -R "$ACTUAL_USER:$ACTUAL_USER" "$DEVELOPER_DIR"
    
    echo -e "${GREEN}>>> Developer structure created at $DEVELOPER_DIR${NC}"
    echo -e "${GREEN}>>> Owner: $ACTUAL_USER${NC}"
    echo -e "${GREEN}>>> Configs: $CONFIGS_DIR${NC}"
    echo -e "${GREEN}>>> Volumes: $VOLUMES_DIR${NC}"
    return 0
}

# Create directory structure at script start
create_developer_structure

# Initialize docker-compose and config files immediately after directory creation
init_docker_compose
init_config_file

# Debug: Verify files were created
if [ -f "$COMPOSE_FILE" ]; then
    echo -e "${GREEN}>>> SUCCESS: docker-compose.yml created at $COMPOSE_FILE${NC}"
else
    echo -e "${RED}>>> ERROR: Failed to create docker-compose.yml at $COMPOSE_FILE${NC}"
fi

if [ -f "$CONFIG_FILE" ]; then
    echo -e "${GREEN}>>> SUCCESS: Config file created at $CONFIG_FILE${NC}"
else
    echo -e "${RED}>>> ERROR: Failed to create config file at $CONFIG_FILE${NC}"
fi

# --- Docker Compose Management ---
init_docker_compose() {
    if [ ! -f "$COMPOSE_FILE" ]; then
        echo -e "\n${GREEN}>>> Creating docker-compose.yml file...${NC}"
        ACTUAL_USER="${SUDO_USER:-$USER}"
        
        # Create the file with proper content
        cat > "$COMPOSE_FILE" << 'EOF'
version: '3.8'

services:
  # Services will be added here dynamically

volumes:
  # Named volumes will be added here dynamically

networks:
  rpi_network:
    driver: bridge
EOF
        
        # Set proper ownership
        sudo chown "$ACTUAL_USER:$ACTUAL_USER" "$COMPOSE_FILE"
        echo -e "${GREEN}>>> Docker compose file created at $COMPOSE_FILE${NC}"
    fi
}

init_config_file() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo -e "\n${GREEN}>>> Creating container configuration file...${NC}"
        ACTUAL_USER="${SUDO_USER:-$USER}"
        
        # Create the file with proper content
        cat > "$CONFIG_FILE" << 'EOF'
#=========================================
# Docker Container Configuration File
# Generated by Raspberry Pi Setup Script
#=========================================

# This file contains important configuration details for all Docker containers
# including URLs, credentials, and access information.

EOF
        
        # Set proper ownership
        sudo chown "$ACTUAL_USER:$ACTUAL_USER" "$CONFIG_FILE"
        echo -e "${GREEN}>>> Config file created at $CONFIG_FILE${NC}"
    fi
}

add_service_config() {
    local service_name=$1
    local config_info=$2
    local ACTUAL_USER="${SUDO_USER:-$USER}"
    
    # Check if service config already exists
    if grep -q "## $service_name Configuration" "$CONFIG_FILE"; then
        echo -e "${YELLOW}>>> Configuration for $service_name already exists${NC}"
        return 0
    fi
    
    # Add service configuration
    cat >> "$CONFIG_FILE" << EOF

## $service_name Configuration
$config_info

EOF
    
    # Ensure proper ownership
    sudo chown "$ACTUAL_USER:$ACTUAL_USER" "$CONFIG_FILE"
    echo -e "${GREEN}>>> Added $service_name configuration to config file${NC}"
}

add_service_to_compose() {
    local service_name=$1
    local service_config=$2
    
    # Check if service already exists
    if grep -q "^  $service_name:" "$COMPOSE_FILE"; then
        echo -e "${YELLOW}>>> Service $service_name already exists in docker-compose.yml${NC}"
        return 0
    fi
    
    # Add service to compose file
    sed -i "/^services:/a\\$service_config" "$COMPOSE_FILE"
    echo -e "${GREEN}>>> Added $service_name to docker-compose.yml${NC}"
}

# --- ASCII Art Logo ---
# Generated with figlet: figlet -f standard "RPI Setup"
show_logo() {
    printf "%b" "${BLUE}"
    echo "                     _                                  _ "
    echo " _ __ __ _ ___ _ __ | |__   ___ _ __ _ __ _   _   _ __ (_)"
    echo "| '__/ _\`/ __| '_ \| '_ \ / _ \ '__| '__| | | | | '_ \| |"
    echo "| | | (_| \__ \ |_) | |_) |  __/ |  | |  | |_| | | |_) | |"
    echo "|_|  \__,_|___/ .__/|_.__/ \___|_|  |_|   \__, | | .__/|_|"
    echo "              |_|                         |___/  |_|      "
    printf "%b" "${NC}"
}


# --- Status Check Functions ---
# Returns 0 (true) if installed, 1 (false) otherwise.
is_python_installed() { command -v python3 &>/dev/null && command -v pip3 &>/dev/null; }
is_screen_installed() { command -v screen &>/dev/null; }
is_git_installed() { command -v git &>/dev/null; }
is_docker_installed() { command -v docker &>/dev/null; }
is_ufw_installed() { command -v ufw &>/dev/null; }

# Docker service status checks
is_service_running() {
    local service_name=$1
    if is_docker_installed; then
        docker ps --format '{{.Names}}' | grep -q "^${service_name}$"
    else
        return 1
    fi
}


# --- Progress Bar ---
# $1: current step, $2: total steps, $3: message
show_progress() {
    local current=$1
    local total=$2
    local message=$3
    local percent=$(( (current * 100) / total ))
    local filled_len=$(( (percent * 40) / 100 ))
    local bar=$(printf "%${filled_len}s" | tr ' ' '#')
    local empty_bar=$(printf "%$((40 - filled_len))s")
    
    echo -ne "\r[${GREEN}${bar}${NC}${empty_bar}] ${percent}% - ${YELLOW}${message}${NC}"
}


# --- Installation Functions ---

# 1. Update and Upgrade System
update_system() {
    echo -e "\n${GREEN}>>> Starting system update and upgrade...${NC}"
    if sudo apt-get update && sudo apt-get upgrade -y; then
        echo -e "\n${GREEN}>>> System updated and upgraded successfully.${NC}"
        UPDATE_RUN_THIS_SESSION=true
        return 0
    else
        echo -e "\n${RED}>>> Action failed. Please check your internet connection and permissions.${NC}"
        return 1
    fi
}

# 2. Install Python, Pip, and Venv
install_python() {
    if is_python_installed; then
        echo -e "\n${YELLOW}>>> Python is already installed.${NC}"
        return 0
    fi
    echo -e "\n${GREEN}>>> Installing Python 3, pip, and venv...${NC}"
    if sudo apt-get install -y python3 python3-pip python3-venv; then
        echo -e "\n${GREEN}>>> Python 3, pip, and venv installed successfully.${NC}"
        return 0
    else
        echo -e "\n${RED}>>> Installation failed.${NC}"
        return 1
    fi
}

# 14. Install UFW and Configure Firewall
install_ufw() {
    if is_ufw_installed; then
        echo -e "\n${YELLOW}>>> UFW is already installed.${NC}"
    else
        echo -e "\n${GREEN}>>> Installing UFW (Uncomplicated Firewall)...${NC}"
        if ! sudo apt-get install -y ufw; then
            echo -e "\n${RED}>>> UFW installation failed.${NC}"
            return 1
        fi
    fi
    
    echo -e "\n${GREEN}>>> Configuring UFW firewall rules...${NC}"
    
    # Always allow SSH
    sudo ufw allow ssh
    echo -e "${GREEN}>>> SSH (port 22) - Allowed${NC}"
    
    # Check for running services and open ports
    if docker ps --format '{{.Names}}' | grep -q "^mongodb$"; then
        sudo ufw allow 27017
        echo -e "${GREEN}>>> MongoDB (port 27017) - Allowed${NC}"
    fi
    
    if docker ps --format '{{.Names}}' | grep -q "^mysql-db$"; then
        sudo ufw allow 3306
        echo -e "${GREEN}>>> MySQL (port 3306) - Allowed${NC}"
    fi
    
    if docker ps --format '{{.Names}}' | grep -q "^influxdb$"; then
        sudo ufw allow 8086
        echo -e "${GREEN}>>> InfluxDB (port 8086) - Allowed${NC}"
    fi
    
    if docker ps --format '{{.Names}}' | grep -q "^portainer$"; then
        sudo ufw allow 9000
        sudo ufw allow 9443
        echo -e "${GREEN}>>> Portainer (ports 9000, 9443) - Allowed${NC}"
    fi
    
    if docker ps --format '{{.Names}}' | grep -q "^traefik$"; then
        sudo ufw allow 80
        sudo ufw allow 443
        sudo ufw allow 8080
        echo -e "${GREEN}>>> Traefik (ports 80, 443, 8080) - Allowed${NC}"
    fi
    
    if docker ps --format '{{.Names}}' | grep -q "^grafana$"; then
        sudo ufw allow 3000
        echo -e "${GREEN}>>> Grafana (port 3000) - Allowed${NC}"
    fi
    
    # Enable UFW
    sudo ufw --force enable
    echo -e "\n${GREEN}>>> UFW enabled and configured. Current status:${NC}"
    sudo ufw status numbered
    return 0
}

# 4. Install Screen
install_screen() {
    if is_screen_installed; then
        echo -e "\n${YELLOW}>>> Screen is already installed.${NC}"
        return 0
    fi
    echo -e "\n${GREEN}>>> Installing screen...${NC}"
    if sudo apt-get install -y screen; then
        echo -e "\n${GREEN}>>> Screen installed successfully.${NC}"
        return 0
    else
        echo -e "\n${RED}>>> Installation failed.${NC}"
        return 1
    fi
}

# 5. Install Git
install_git() {
    if command -v git &>/dev/null; then
        echo -e "\n${YELLOW}>>> Git is already installed.${NC}"
        return 0
    fi
    echo -e "\n${GREEN}>>> Installing Git...${NC}"
    if sudo apt-get install -y git; then
        echo -e "\n${GREEN}>>> Git installed successfully.${NC}"
        echo -e "${YELLOW}>>> Remember to configure Git with:${NC}"
        echo -e "${YELLOW}>>>   git config --global user.name \"Your Name\"${NC}"
        echo -e "${YELLOW}>>>   git config --global user.email \"your.email@example.com\"${NC}"
        return 0
    else
        echo -e "\n${RED}>>> Installation failed.${NC}"
        return 1
    fi
}

# 6. Install Docker
install_docker() {
    if is_docker_installed; then
        echo -e "\n${YELLOW}>>> Docker is already installed.${NC}"
        return 0
    fi
    
    echo -e "\n${GREEN}>>> Installing Docker...${NC}"
    echo -e "${YELLOW}>>> Downloading Docker installation script...${NC}"
    if ! curl -fsSL https://get.docker.com -o get-docker.sh; then
        echo -e "\n${RED}>>> Failed to download Docker script.${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}>>> Running Docker installation script...${NC}"
    sudo sh get-docker.sh
    
    # Get the actual user (not root when using sudo)
    ACTUAL_USER="${SUDO_USER:-$USER}"
    
    # Check if user is already in docker group
    if groups "$ACTUAL_USER" | grep -q '\bdocker\b'; then
        echo -e "${GREEN}>>> User '$ACTUAL_USER' is already in the docker group.${NC}"
    else
        echo -e "${YELLOW}>>> Adding user '$ACTUAL_USER' to the 'docker' group...${NC}"
        sudo usermod -aG docker "$ACTUAL_USER"
        echo -e "${GREEN}>>> User '$ACTUAL_USER' added to docker group successfully.${NC}"
        echo -e "${YELLOW}>>> Note: User '$ACTUAL_USER' needs to log out and back in for group changes to take effect.${NC}"
    fi
    
    echo -e "${YELLOW}>>> Enabling and starting Docker service...${NC}"
    sudo systemctl enable docker
    sudo systemctl start docker
    
    rm get-docker.sh
    
    echo -e "\n${GREEN}>>> Docker installed and configured successfully.${NC}"
    echo -e "${YELLOW}>>> IMPORTANT: You may need to log out and log back in to run 'docker' without 'sudo'.${NC}"
    return 0
}

# 7. Install MongoDB on Docker
install_mongodb() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling MongoDB image and adding to docker-compose...${NC}"
    
    # Pull MongoDB image
    if ! docker pull mongo:latest; then
        echo -e "\n${RED}>>> Failed to pull MongoDB image.${NC}"
        return 1
    fi
    
    # Add MongoDB service to docker-compose
    local mongodb_service='
  mongodb:
    image: mongo:latest
    container_name: mongodb
    restart: unless-stopped
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ../volumes/mongodb:/backup
    networks:
      - rpi_network
    environment:
      - MONGO_INITDB_DATABASE=admin'
    
    # Add the service
    sed -i '/^services:/a\'"$mongodb_service" "$COMPOSE_FILE"
    
    # Add volume to volumes section
    if ! grep -q "mongodb_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  mongodb_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local mongodb_config="Service: MongoDB
Image: mongo:latest
Container Name: mongodb
Port: 27017
Connection URL: mongodb://localhost:27017
Database: admin
Volume Path: $VOLUMES_DIR/mongodb
Backup Path: $VOLUMES_DIR/mongodb
Status: Configured (not started)"
    
    add_service_config "MongoDB" "$mongodb_config"
    
    echo -e "\n${GREEN}>>> MongoDB image pulled and added to docker-compose.${NC}"
    echo -e ">>> Run 'docker-compose up -d mongodb' in $CONFIGS_DIR to start"
    return 0
}

# 8. Install MySQL on Docker
install_mysql() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling MySQL image and adding to docker-compose...${NC}"
    
    # Pull MySQL image
    if ! docker pull mysql:latest; then
        echo -e "\n${RED}>>> Failed to pull MySQL image.${NC}"
        return 1
    fi
    
    # Use default password
    local MYSQL_ROOT_PASSWORD="defaultpassword"
    
    # Add MySQL service to docker-compose
    local mysql_service="
  mysql-db:
    image: mysql:latest
    container_name: mysql-db
    restart: unless-stopped
    ports:
      - \"3306:3306\"
    volumes:
      - mysql_data:/var/lib/mysql
      - ../volumes/mysqldb:/backup
    networks:
      - rpi_network
    environment:
      - MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD
      - MYSQL_DATABASE=development"
    
    # Add the service
    sed -i '/^services:/a\'"$mysql_service" "$COMPOSE_FILE"
    
    # Add volume to volumes section
    if ! grep -q "mysql_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  mysql_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local mysql_config="Service: MySQL Database
Image: mysql:latest
Container Name: mysql-db
Port: 3306
Connection URL: mysql://localhost:3306
Username: root
Password: $MYSQL_ROOT_PASSWORD
Default Database: development
Volume Path: $VOLUMES_DIR/mysqldb
Backup Path: $VOLUMES_DIR/mysqldb
Status: Configured (not started)"
    
    add_service_config "MySQL" "$mysql_config"
    
    echo -e "\n${GREEN}>>> MySQL image pulled and added to docker-compose.${NC}"
    echo -e ">>> Default password: $MYSQL_ROOT_PASSWORD (change after deployment)"
    echo -e ">>> Run 'docker-compose up -d mysql-db' in $CONFIGS_DIR to start"
    return 0
}

# 9. Install SQLite Tools
install_sqlite_docker() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    if [ -f /usr/local/bin/run-sqlite3 ]; then
        echo -e "\n${YELLOW}>>> SQLite helper script is already installed.${NC}"
        return 0
    fi
    echo -e "\n${GREEN}>>> Setting up SQLite tools on Docker...${NC}"
    echo -e "${YELLOW}>>> SQLite is a file-based database, so we will install a helper script.${NC}"
    
    echo -e "${YELLOW}>>> Creating helper script at '/usr/local/bin/run-sqlite3'...${NC}"
    cat <<EOF | tee /usr/local/bin/run-sqlite3 > /dev/null
#!/bin/bash
# Helper script to run sqlite3 in a Docker container
DATA_DIR="$VOLUMES_DIR/sqlite"
mkdir -p "\$DATA_DIR"
echo "Using database files in: \$DATA_DIR"
docker run -it --rm -v "\$DATA_DIR":/root/db nouchka/sqlite3 "\$@"
EOF

    chmod +x /usr/local/bin/run-sqlite3
    
    # Add configuration information
    local sqlite_config="Service: SQLite Database Tools
Image: nouchka/sqlite3
Helper Script: /usr/local/bin/run-sqlite3
Usage: run-sqlite3 your_database.db
Volume Path: $VOLUMES_DIR/sqlite
Backup Path: $VOLUMES_DIR/sqlite
Status: Available
Notes: File-based database, no persistent container"
    
    add_service_config "SQLite" "$sqlite_config"
    
    echo -e "\n${GREEN}>>> SQLite helper installed successfully.${NC}"
    echo -e ">>> Run: run-sqlite3 your_database.db"
    echo -e ">>> Data stored in: $VOLUMES_DIR/sqlite"
    return 0
}

# 10. Install InfluxDB on Docker
install_influxdb() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling InfluxDB image and adding to docker-compose...${NC}"
    
    # Pull InfluxDB image
    if ! docker pull influxdb:2.7; then
        echo -e "\n${RED}>>> Failed to pull InfluxDB image.${NC}"
        return 1
    fi
    
    local influxdb_service='
  influxdb:
    image: influxdb:2.7
    container_name: influxdb
    restart: unless-stopped
    ports:
      - "8086:8086"
    volumes:
      - influxdb_data:/var/lib/influxdb2
      - ../volumes/influxdb:/backup
    networks:
      - rpi_network
    environment:
      - DOCKER_INFLUXDB_INIT_MODE=setup
      - DOCKER_INFLUXDB_INIT_USERNAME=admin
      - DOCKER_INFLUXDB_INIT_PASSWORD=password123
      - DOCKER_INFLUXDB_INIT_ORG=myorg
      - DOCKER_INFLUXDB_INIT_BUCKET=mybucket'
    
    sed -i '/^services:/a\'"$influxdb_service" "$COMPOSE_FILE"
    
    if ! grep -q "influxdb_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  influxdb_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local influxdb_config="Service: InfluxDB Time Series Database
Image: influxdb:2.7
Container Name: influxdb
Port: 8086
Web UI URL: http://localhost:8086
Username: admin
Password: password123
Organization: myorg
Bucket: mybucket
Volume Path: $VOLUMES_DIR/influxdb
Backup Path: $VOLUMES_DIR/influxdb
Status: Configured (not started)"
    
    add_service_config "InfluxDB" "$influxdb_config"
    
    echo -e "\n${GREEN}>>> InfluxDB image pulled and added to docker-compose.${NC}"
    echo -e ">>> Default login: admin/password123"
    echo -e ">>> Run 'docker-compose up -d influxdb' in $CONFIGS_DIR to start"
    return 0
}

# 11. Install Portainer on Docker
install_portainer() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling Portainer image and adding to docker-compose...${NC}"
    
    # Pull Portainer image
    if ! docker pull portainer/portainer-ce:latest; then
        echo -e "\n${RED}>>> Failed to pull Portainer image.${NC}"
        return 1
    fi
    
    local portainer_service='
  portainer:
    image: portainer/portainer-ce:latest
    container_name: portainer
    restart: unless-stopped
    ports:
      - "9000:9000"
      - "9443:9443"
    volumes:
      - portainer_data:/data
      - /var/run/docker.sock:/var/run/docker.sock
      - ../volumes/portainer:/backup
    networks:
      - rpi_network'
    
    sed -i '/^services:/a\'"$portainer_service" "$COMPOSE_FILE"
    
    if ! grep -q "portainer_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  portainer_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local portainer_config="Service: Portainer Docker Management
Image: portainer/portainer-ce:latest
Container Name: portainer
Ports: 9000 (HTTP), 9443 (HTTPS)
Web UI URL: https://localhost:9443
Alternative URL: http://localhost:9000
Initial Setup: Create admin user on first access
Volume Path: $VOLUMES_DIR/portainer
Backup Path: $VOLUMES_DIR/portainer
Status: Configured (not started)"
    
    add_service_config "Portainer" "$portainer_config"
    
    echo -e "\n${GREEN}>>> Portainer image pulled and added to docker-compose.${NC}"
    echo -e ">>> Run 'docker-compose up -d portainer' in $CONFIGS_DIR to start"
    return 0
}

# 12. Install Traefik on Docker
install_traefik() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling Traefik image and adding to docker-compose...${NC}"
    
    # Pull Traefik image
    if ! docker pull traefik:v3.0; then
        echo -e "\n${RED}>>> Failed to pull Traefik image.${NC}"
        return 1
    fi
    
    # Create traefik config directory
    mkdir -p "$VOLUMES_DIR/traefik"
    
    # Create basic traefik config
    cat > "$VOLUMES_DIR/traefik/traefik.yml" << 'EOF'
api:
  dashboard: true
  insecure: true

entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"

providers:
  docker:
    exposedByDefault: false
EOF
    
    local traefik_service='
  traefik:
    image: traefik:v3.0
    container_name: traefik
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ../volumes/traefik/traefik.yml:/etc/traefik/traefik.yml
      - traefik_data:/data
    networks:
      - rpi_network'
    
    sed -i '/^services:/a\'"$traefik_service" "$COMPOSE_FILE"
    
    if ! grep -q "traefik_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  traefik_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local traefik_config="Service: Traefik Reverse Proxy & Load Balancer
Image: traefik:v3.0
Container Name: traefik
Ports: 80 (HTTP), 443 (HTTPS), 8080 (Dashboard)
Dashboard URL: http://localhost:8080
Configuration File: $VOLUMES_DIR/traefik/traefik.yml
Volume Path: $VOLUMES_DIR/traefik
Backup Path: $VOLUMES_DIR/traefik
Status: Configured (not started)
Notes: Manages routing for other services"
    
    add_service_config "Traefik" "$traefik_config"
    
    echo -e "\n${GREEN}>>> Traefik image pulled and added to docker-compose.${NC}"
    echo -e ">>> Dashboard URL: http://localhost:8080"
    echo -e ">>> Run 'docker-compose up -d traefik' in $CONFIGS_DIR to start"
    return 0
}

# 13. Install Grafana on Docker
install_grafana() {
    if ! is_docker_installed; then
        echo -e "\n${RED}>>> Docker is not installed. Please install Docker first.${NC}"
        return 1
    fi
    
    echo -e "\n${GREEN}>>> Pulling Grafana image and adding to docker-compose...${NC}"
    
    # Pull Grafana image
    if ! docker pull grafana/grafana:latest; then
        echo -e "\n${RED}>>> Failed to pull Grafana image.${NC}"
        return 1
    fi
    
    local grafana_service='
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    volumes:
      - grafana_data:/var/lib/grafana
      - ../volumes/grafana:/backup
    networks:
      - rpi_network
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin123'
    
    sed -i '/^services:/a\'"$grafana_service" "$COMPOSE_FILE"
    
    if ! grep -q "grafana_data:" "$COMPOSE_FILE"; then
        sed -i '/^volumes:/a\  grafana_data:' "$COMPOSE_FILE"
    fi
    
    # Add configuration information
    local grafana_config="Service: Grafana Data Visualization & Monitoring
Image: grafana/grafana:latest
Container Name: grafana
Port: 3000
Web UI URL: http://localhost:3000
Username: admin
Password: admin123
Volume Path: $VOLUMES_DIR/grafana
Backup Path: $VOLUMES_DIR/grafana
Status: Configured (not started)
Notes: Change default password on first login"
    
    add_service_config "Grafana" "$grafana_config"
    
    echo -e "\n${GREEN}>>> Grafana image pulled and added to docker-compose.${NC}"
    echo -e ">>> Default login: admin/admin123"
    echo -e ">>> Run 'docker-compose up -d grafana' in $CONFIGS_DIR to start"
    return 0
}


# --- Selective Installation Function ---
run_selective_install() {
    local input=$1
    
    # Parse comma-separated input
    IFS=',' read -ra TASKS <<< "$input"
    local task_functions=()
    local task_names=()
    
    for task_num in "${TASKS[@]}"; do
        # Remove any whitespace
        task_num=$(echo "$task_num" | tr -d ' ')
        
        case $task_num in
            1) task_functions+=(update_system); task_names+=("Update System") ;;
            2) task_functions+=(install_python); task_names+=("Install Python") ;;
            3) task_functions+=(install_screen); task_names+=("Install Screen") ;;
            4) task_functions+=(install_git); task_names+=("Install Git") ;;
            5) task_functions+=(install_docker); task_names+=("Install Docker") ;;
            6) task_functions+=(install_mongodb); task_names+=("Install MongoDB") ;;
            7) task_functions+=(install_mysql); task_names+=("Install MySQL") ;;
            8) task_functions+=(install_sqlite_docker); task_names+=("Install SQLite") ;;
            9) task_functions+=(install_influxdb); task_names+=("Install InfluxDB") ;;
            10) task_functions+=(install_portainer); task_names+=("Install Portainer") ;;
            11) task_functions+=(install_traefik); task_names+=("Install Traefik") ;;
            12) task_functions+=(install_grafana); task_names+=("Install Grafana") ;;
            13) task_functions+=(install_ufw); task_names+=("Configure UFW") ;;
            *) 
                echo -e "\n${RED}Invalid option: $task_num${NC}"
                return 1
                ;;
        esac
    done
    
    if [ ${#task_functions[@]} -eq 0 ]; then
        echo -e "\n${RED}No valid tasks specified.${NC}"
        return 1
    fi
    
    local total=${#task_functions[@]}
    local current=0
    
    echo -e "\n${GREEN}>>> Running selective installation for: ${task_names[*]}${NC}"
    
    for i in "${!task_functions[@]}"; do
        current=$((current + 1))
        show_progress $current $total "Running: ${task_names[$i]}"
        ${task_functions[$i]}
        if [ $? -ne 0 ]; then
            echo -e "\n${RED}Task ${task_names[$i]} failed. Continuing with remaining tasks...${NC}"
        fi
        sleep 1
    done
    
    echo -e "\n${GREEN}>>> Selective installation completed!${NC}"
    return 0
}


# --- Main Menu ---
show_menu() {
    clear
    show_logo
    echo "--------------------------------------------------"
    echo "        Raspberry Pi Development Setup"
    echo "--------------------------------------------------"
    echo "Individual Installation Options:"
    echo ""
    
    # Check status for each item
    [[ "$UPDATE_RUN_THIS_SESSION" = true ]] && s1="${GREEN}Done${NC}" || s1="${RED}Pending${NC}"
    is_python_installed && s2="${GREEN}Installed${NC}" || s2="${RED}Not Installed${NC}"
    is_screen_installed && s3="${GREEN}Installed${NC}" || s3="${RED}Not Installed${NC}"
    is_git_installed && s4="${GREEN}Installed${NC}" || s4="${RED}Not Installed${NC}"
    is_docker_installed && s5="${GREEN}Installed${NC}" || s5="${RED}Not Installed${NC}"
    
    # Docker services status
    is_service_running "mongodb" && s6="${GREEN}Running${NC}" || s6="${RED}Not Running${NC}"
    is_service_running "mysql-db" && s7="${GREEN}Running${NC}" || s7="${RED}Not Running${NC}"
    [ -f /usr/local/bin/run-sqlite3 ] && s8="${GREEN}Installed${NC}" || s8="${RED}Not Installed${NC}"
    is_service_running "influxdb" && s9="${GREEN}Running${NC}" || s9="${RED}Not Running${NC}"
    is_service_running "portainer" && s10="${GREEN}Running${NC}" || s10="${RED}Not Running${NC}"
    is_service_running "traefik" && s11="${GREEN}Running${NC}" || s11="${RED}Not Running${NC}"
    is_service_running "grafana" && s12="${GREEN}Running${NC}" || s12="${RED}Not Running${NC}"
    is_ufw_installed && s13="${GREEN}Installed${NC}" || s13="${RED}Not Installed${NC}"

    printf "   1. Update and Upgrade System      [%b]\n" "$s1"
    printf "   2. Install Python, Pip, and Venv  [%b]\n" "$s2"
    printf "   3. Install Screen                 [%b]\n" "$s3"
    printf "   4. Install Git                    [%b]\n" "$s4"
    printf "   5. Install Docker & Setup         [%b]\n" "$s5"
    printf "   6. Install MongoDB (Docker)       [%b]\n" "$s6"
    printf "   7. Install MySQL (Docker)         [%b]\n" "$s7"
    printf "   8. Install SQLite Tools           [%b]\n" "$s8"
    printf "   9. Install InfluxDB (Docker)      [%b]\n" "$s9"
    printf "   10. Install Portainer (Docker)    [%b]\n" "$s10"
    printf "   11. Install Traefik (Docker)      [%b]\n" "$s11"
    printf "   12. Install Grafana (Docker)      [%b]\n" "$s12"
    printf "   13. Configure UFW Firewall        [%b]\n" "$s13"
    echo ""
    echo "Batch Installation:"
    echo "   a. Install ALL (Complete setup - runs options 1-13)"
    echo ""
    echo "Selective Installation:"
    echo "   s. Select multiple (e.g., '1,2,5,6,13')"
    echo ""
    echo "   q. Quit"
    echo "--------------------------------------------------"
    if [ -f "$COMPOSE_FILE" ]; then
        echo "Docker Compose: $COMPOSE_FILE"
        echo "Container Configs: $CONFIG_FILE"
        echo "Volume Storage: $VOLUMES_DIR"
    fi
    echo "--------------------------------------------------"
}


# --- Helper Functions ---
show_installation_header() {
    local task_name="$1"
    echo -e "${YELLOW}======================================${NC}"
    echo -e "${YELLOW}  Installing: $task_name${NC}"
    echo -e "${YELLOW}======================================${NC}"
    echo ""
}

install_all() {
    clear
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}  COMPLETE RASPBERRY PI SETUP${NC}"
    echo -e "${GREEN}======================================${NC}"
    echo -e "${YELLOW}This will install ALL components in sequence.${NC}"
    echo -e "${YELLOW}Estimated time: 15-30 minutes${NC}"
    echo ""
    read -p "Continue with complete installation? (y/N): " confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Installation cancelled.${NC}"
        return 0
    fi
    
    echo -e "\n${GREEN}Starting complete installation...${NC}\n"
    
    # Run all installations in sequence
    clear; show_installation_header "System Update"; update_system
    clear; show_installation_header "Python Installation"; install_python
    clear; show_installation_header "Screen Installation"; install_screen
    clear; show_installation_header "Git Installation"; install_git
    clear; show_installation_header "Docker Installation"; install_docker
    clear; show_installation_header "MongoDB Installation"; install_mongodb
    clear; show_installation_header "MySQL Installation"; install_mysql
    clear; show_installation_header "SQLite Installation"; install_sqlite_docker
    clear; show_installation_header "InfluxDB Installation"; install_influxdb
    clear; show_installation_header "Portainer Installation"; install_portainer
    clear; show_installation_header "Traefik Installation"; install_traefik
    clear; show_installation_header "Grafana Installation"; install_grafana
    clear; show_installation_header "UFW Firewall Configuration"; install_ufw
    
    clear
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}  INSTALLATION COMPLETE!${NC}"
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}All components have been installed successfully.${NC}"
    echo -e "${YELLOW}Docker containers are configured but not started.${NC}"
    echo -e "${YELLOW}Use docker-compose commands to start services as needed.${NC}"
    echo ""
    echo -e "Docker Compose File: ${BLUE}$COMPOSE_FILE${NC}"
    echo -e "Configuration File:  ${BLUE}$CONFIG_FILE${NC}"
    echo -e "Volume Directory:    ${BLUE}$VOLUMES_DIR${NC}"
    echo ""
}

# --- Main Loop ---
while true; do
    show_menu
    read -p "Enter your choice [1-13, a, s, q]: " choice

    case $choice in
        1) clear; show_installation_header "System Update"; update_system ;;
        2) clear; show_installation_header "Python Installation"; install_python ;;
        3) clear; show_installation_header "Screen Installation"; install_screen ;;
        4) clear; show_installation_header "Git Installation"; install_git ;;
        5) clear; show_installation_header "Docker Installation"; install_docker ;;
        6) clear; show_installation_header "MongoDB Installation"; install_mongodb ;;
        7) clear; show_installation_header "MySQL Installation"; install_mysql ;;
        8) clear; show_installation_header "SQLite Installation"; install_sqlite_docker ;;
        9) clear; show_installation_header "InfluxDB Installation"; install_influxdb ;;
        10) clear; show_installation_header "Portainer Installation"; install_portainer ;;
        11) clear; show_installation_header "Traefik Installation"; install_traefik ;;
        12) clear; show_installation_header "Grafana Installation"; install_grafana ;;
        13) clear; show_installation_header "UFW Firewall Configuration"; install_ufw ;;
        a|A) install_all ;;
        s|S)
            echo -e "\n${YELLOW}Enter the numbers separated by commas (e.g., 1,2,5,6,13):${NC}"
            read -p "Selection: " selection
            if [ -n "$selection" ]; then
                run_selective_install "$selection"
            else
                echo -e "${RED}No selection provided.${NC}"
            fi
            ;;
        q|Q)
            echo -e "\n${YELLOW}Exiting script. Goodbye!${NC}\n"
            exit 0
            ;;
        *)
            echo -e "\n${RED}Invalid option. Please try again.${NC}"
            ;;
    esac
    
    echo -e "\nPress ${YELLOW}Enter${NC} to return to the menu..."
    read -r
done
